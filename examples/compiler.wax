(@define CHAR_TAB 9)
(@define CHAR_NL 10)
(@define CHAR_SPACE 32)
(@define CHAR_DOUBLE_QUOTE 34)
(@define CHAR_PAREN_OPEN 40)
(@define CHAR_PAREN_CLOSE 41)

(func tokens_parse (param input str) (result (arr str))
	(let token str (alloc str))
	(let tokens (arr str) (alloc (arr str)))
	(let in_quote int 0)

	(for i 0 (< i (# input)) 1 (do
		(let c int (get input i))

		(let whitespace int (|| (= c @CHAR_TAB) (= c @CHAR_SPACE) (= c @CHAR_NL)))
		(let paren int (|| (= c @CHAR_PAREN_OPEN) (= c @CHAR_PAREN_CLOSE)))

		(if (= c @CHAR_DOUBLE_QUOTE) (then (set in_quote (! in_quote))))

		(if (&& (! in_quote) (|| whitespace paren)) (then
			(if (<> 0 (# token)) (then
				(insert tokens (# tokens) token)
			))

			(if paren (then
				(set token "")
				(<< token c)
 				(insert tokens (# tokens) token)
			))

			(set token "")
			)
			(else
				(<< token c)
			)
		)
	))

	(return tokens)
)

(@define NODE_ROOT 0)
(@define NODE_EXPR 1)
(@define NODE_INT 2)
(@define NODE_STR 3)

(struct node
	(let type int)
	(let value str)
	(let child (arr (struct node)))
)

(func prog_helloworld (result str)
	(let lines (arr str) (alloc (arr str)
		"\n"
		"(func main (result int)\n"
		"  (print \"Hello World!\")\n"
		"  (return 0)\n"
		")\n"
	))

	(let prog str (alloc str ""))
	(for i 0 (< i (# lines)) 1 (do
		(<< prog (get lines i))
	))

	(return prog)
)

(func prog_vecmap (result str)
	(let lines (arr str) (alloc (arr str)
		"\n"
		"(func main (result int)\n"
		"  (let things (arr float) (alloc (arr float)))\n"
		"  (insert things 0 4.0)\n"
		"  (insert things 0 3.0)\n"
		"  (insert things 0 3.1)\n"
 		"  (insert things 0 3.2)\n"
		"  (insert things 0 1.0)\n"
		"  (insert things 1 2.0)\n"
		"  (remove things 2 2)\n"
		"  (for i 0 (< i (# things)) 1 (do\n"
		"    (print (get things i))\n"
		"  ))\n"
		"  (return 0)\n"
		")\n"
	))

	(let prog str (alloc str ""))
	(for i 0 (< i (# lines)) 1 (do
		(<< prog (get lines i))
	))

	(return prog)
)

(func prog_fib (result str)
	(let lines (arr str) (alloc (arr str)
		"(func fib (param i int) (param i2 int) (result int)\n"
		"	(if (<= i 1) (then\n"
		"		(return i)\n"
		"	))\n"
		"	(return (+\n"
		"		(call fib (- i 1))\n"
		"		(call fib (- i 2))\n"
		"	))\n"
		")\n"
		"\n"
		"(func main (result int)\n"
		"	(let x int (call fib 9))\n"
		"	(print x)\n"
		"	(return 0)\n"
		")\n"
	))

	(let prog str (alloc str ""))
	(for i 0 (< i (# lines)) 1 (do
		(<< prog (get lines i))
	))

	(return prog)
)

(func prog_nqueens (result str)
	(let lines (arr str) (alloc (arr str)
		"(func attackable (param B (vec 8 int)) (param y int) (result int) (let x int (get B y))	(for i 1 (<= i y) 1 (do"
		"(let t int (get B (- y i)))	(if (||	(= t x) (= t (- x i)) (= t (+ x i))) (then (return 1) )))) (return 0))"
		"(func putboard (param B (vec 8 int)) (param s int) (local o str (alloc str \"N=\")) (<< o (cast 8 str))(<< o \""
		" solution #\") (<< o (cast s str))	(<< o \"\\n\")	(for y 0 (< y 8) 1 (do (for x 0 (< x 8) 1 (do (<< o	(? (= (get B y)"
		"x) \"|Q\" \"|_\")) )) (<< o \"|\\n\"))) (print o)) (func solve (local B (vec 8 int) (alloc (vec 8 int))) (let s int 0)"
		"(let y int 0)  (set B 0 -1) (while (>= y 0) (do (set B y (+ (get B y) 1)) (while (&& (< (get B y) 8) (call "
		"attackable B y) )(do (set B y (+ (get B y) 1)) )) (if (< (get B y) 8) (then (if (< y (- 8 1)) (then (set y (+ y 1))"
		"(set B y -1) ) (else (set s (+ s 1)) (call putboard B s) )) )(else (set y (- y 1)) )) ))) (func main (result int) "
		"(call solve) (return 0))"
	))

	(let prog str (alloc str ""))
	(for i 0 (< i (# lines)) 1 (do
		(<< prog (get lines i))
	))

	(return prog)
)

(func prog_hilbert (result str)
	(let lines (arr str) (alloc (arr str)
		; "(func rot (param n int) (param xy (vec 2 int)) (param rx int) (param ry int) (if (= ry 0) (then (if (= rx 1) (then"
		; "(set xy 0 (- (- n 1) (get xy 0))) (set xy 1 (- (- n 1) (get xy 1))) )) (let t int (get xy 0)) (set xy 0 (get xy 1))"
		; "(set xy 1 t) )) ) (func d2xy (param n int) (param d int) (param xy (vec 2 int)) (let rx int) (let ry int) (let t int d)"
		; "(set xy 0 0) (set xy 1 0) (for s 1 (< s n) s (do (set rx (& 1 (/ t 2))) (set ry (& 1 (^ t rx))) (call rot s xy rx ry)"
		; "(set xy 0 (+ (get xy 0) (* s rx))) (set xy 1 (+ (get xy 1) (* s ry))) (set t (/ t 4))))) (func hilbert_curve (param "
		; "n int) (result (arr (vec 2 int))) (let pts (arr (vec 2 int)) (alloc (arr (vec 2 int)))) (for d 0 (< d (* n n)) 1 "
		; "(do (let xy (vec 2 int) (alloc (vec 2 int))) (call d2xy n d xy) (insert pts (# pts) xy) )) (return pts))"
		; "(func draw_curve (param pts (arr (vec 2 int))) (param n int) (result str) (local canv (arr int) (alloc (arr int)))"
		; "(let m int (- (* n 3) 2)) (for i 0 (< i (* n m)) 1 (do (insert canv (# canv) ' '))) (for i 1 (< i (# pts)) 1 (do"
		; "(let p0 (vec 2 int) (get pts (- i 1))) (let p1 (vec 2 int) (get pts i)) (let dx int (- (get p1 0) (get p0 0)))"
		; "(if (= dx 0) (then (let row int (? (> (get p1 1) (get p0 1)) (get p1 1) (get p0 1) )) (let col int (* (get p1 0) 3))"
		; "(set canv (+ (* row m) col) '|') )(else (let row int (get p1 1)) (let col int (? (< (get p1 0) (get p0 0)) (get p1 0) "
		; "(get p0 0) )) (set col (+ (* col 3) 1)) (set canv (+ (* row m) col  ) '_') (set canv (+ (* row m) col 1) '_')"
		; ")))) (let s str (alloc str)) (for i 0 (< i n) 1 (do (for j 0 (< j m) 1 (do (<< s (get canv (+ (* i m) j)))"
		; ")) (<< s \"\n\") )) (return s)) (func main (result int) (for order 1 (<= order 5) 1 (do (let n int (<< 1 order))"
		; "(local pts (arr (vec 2 int)) (call hilbert_curve n)) (local s str (call draw_curve pts n)) (print s) (for i 0 "
		; "(< i (# pts)) 1 (do (free (get pts i))))))(return 0))"
		"(func rot (param n int) (param xy (vec 2 int)) (param rx int) (param ry int) (if (= ry 0) (then (if (= rx 1) (then"
		"(set xy 0 (- (- n 1) (get xy 0))) (set xy 1 (- (- n 1) (get xy 1))) )) (let t int (get xy 0)) (set xy 0 (get xy 1))"
		"(set xy 1 t) )) ) (func d2xy (param n int) (param d int) (param xy (vec 2 int)) (let rx int) (let ry int) (let t int d)"
		"(set xy 0 0) (set xy 1 0) (for s 1 (< s n) s (do (set rx (& 1 (/ t 2))) (set ry (& 1 (^ t rx))) (call rot s xy rx ry)"
		"(set xy 0 (+ (get xy 0) (* s rx))) (set xy 1 (+ (get xy 1) (* s ry))) (set t (/ t 4))))) (func hilbert_curve (param "
		"n int) (result (arr (vec 2 int))) (let pts (arr (vec 2 int)) (alloc (arr (vec 2 int)))) (for d 0 (< d (* n n)) 1 "
		"(do (let xy (vec 2 int) (alloc (vec 2 int))) (call d2xy n d xy) (insert pts (# pts) xy) )) (return pts))"
		"(func draw_curve (param pts (arr (vec 2 int))) (param n int) (result str) (local canv (arr int) (alloc (arr int)))"
		"(let m int (- (* n 3) 2)) (for i 0 (< i (* n m)) 1 (do (insert canv (# canv) \" \"))) (for i 1 (< i (# pts)) 1 (do"
		"(let p0 (vec 2 int) (get pts (- i 1))) (let p1 (vec 2 int) (get pts i)) (let dx int (- (get p1 0) (get p0 0)))"
		"(if (= dx 0) (then (let row int (? (> (get p1 1) (get p0 1)) (get p1 1) (get p0 1) )) (let col int (* (get p1 0) 3))"
		"(set canv (+ (* row m) col) \"\|\") )(else (let row int (get p1 1)) (let col int (? (< (get p1 0) (get p0 0)) (get p1 0) "
		"(get p0 0) )) (set col (+ (* col 3) 1)) (set canv (+ (* row m) col  ) \"_\") (set canv (+ (* row m) col 1) \"_\")"
		")))) (let s str (alloc str)) (for i 0 (< i n) 1 (do (for j 0 (< j m) 1 (do (<< s (get canv (+ (* i m) j)))"
		")) (<< s \"\\n\") )) (return s)) (func main (result int) (for order 1 (<= order 5) 1 (do (let n int (<< 1 order))"
		"(local pts (arr (vec 2 int)) (call hilbert_curve n)) (local s str (call draw_curve pts n)) (print s) (for i 0 "
		"(< i (# pts)) 1 (do (free (get pts i))))))(return 0))"
	))

	(let prog str (alloc str ""))
	(for i 0 (< i (# lines)) 1 (do
		(<< prog (get lines i))
	))

	(return prog)
)

(func node_new (param type int) (param value str) (result (struct node))
	(let node_new (struct node) (alloc (struct node)))
	(set node_new type type)
	(set node_new value value)
	(set node_new child (alloc (arr (struct node))))
	
	(return node_new)
)

; eg (+ a b c) -> (+ (+ a b) c) 
(func node_expand (param node_org (struct node)) (result (struct node))
	(if (< (# (get node_org child)) 2) (then
		(return node_org)
	))
	
	(let expanded (struct node) (call node_new @NODE_EXPR (get node_org value)))

	(insert (get expanded child) (# (get expanded child)) (get (get node_org child) 0))
	(if (= (# (get node_org child)) 2) (then
		(insert (get expanded child) (# (get expanded child)) (get (get node_org child) 1))
	) (else
		(let expanded_child (struct node) (call node_new @NODE_EXPR (get node_org value)))
		(for i 1 (< i (# (get node_org child))) 1 (do
			(insert (get expanded_child child) (# (get expanded_child child)) (get (get node_org child) i))
		))

		(insert (get expanded child) (# (get expanded child)) expanded_child)
	))
	(return expanded)
)

(func node_from_tokens (param tokens (arr str)) (result (struct node))
	(let stack (arr (struct node)) (alloc (arr (struct node))))
	(insert stack (# stack) (call node_new @NODE_ROOT ""))

	(let i int 0)
	(while (< i (# tokens)) (do
		(let token str (get tokens i))
		(if (= token "(") (then
			(let node (struct node)
				(call node_new @NODE_EXPR (get tokens (+ i 1)))
			)
			(let parent (struct node) (get stack (- (# stack) 1)))
			(insert (get parent child) (# (get parent child)) node)
			(insert stack (# stack) node)
		
			(set i (+ i 1))			
			) 
			(else (if (= token ")") (then
				(remove stack (- (# stack) 1) 1)
			) 
				(else
					(let child (struct node)
						(call node_new @NODE_STR token)
					)
					(let node (struct node) (get stack (- (# stack) 1)))
					(insert (get node child) (# (get node child)) child)
				))
			)
		)

		(set i (+ i 1))
	))

	(return (get stack 0))
)

(func node_to_wax (param depth int) (param node (struct node)) (result str)
	(let indent str (alloc str ""))
	(for i 0 (< i depth) 1 (do
		(<< indent "  ")
	))

	(let s str (alloc str ""))
	
	(if (= (get node type) @NODE_ROOT) (then
		(for i 0 (< i (# (get node child))) 1 (do
			(let child str (call node_to_wax 0 (get (get node child) i)))
			(<< s child)
		))
	))

	(if (= (get node type) @NODE_EXPR) (then
		(let last_child_expr int 0)

		(<< s "\n")
		(<< s indent)
		(<< s "(")
		(<< s (get node value))
		(for i 0 (< i (# (get node child))) 1 (do
			(let node_child (struct node) (get (get node child) i))
			(set last_child_expr (= (get node_child type) @NODE_EXPR))
			(let child str (call node_to_wax (+ depth 1) node_child))
			(<< s " ")
			(<< s child)
		))
		(if last_child_expr (then
			(<< s "\n")
			(<< s indent)
		))
		(<< s ")")
	))

	(if (= (get node type) @NODE_STR) (then
		(<< s (get node value))
	))

	(return s)
)

(func node_to_js (param depth int) (param node (struct node)) (result str)
	(let indent str (alloc str ""))
	(for i 0 (< i depth) 1 (do
		(<< indent "  ")
	))
	
	(let s str (alloc str ""))
	
	(if (= (get node type) @NODE_ROOT) (then
		(for i 0 (< i (# (get node child))) 1 (do
			(let child str (call node_to_js 0 (get (get node child) i)))
			(<< s child)
		))
		
		(<< s "\n\n")
		(<< s "main()\n")
	))

	(if (|| 
		(= (get node value) "+") 
		(= (get node value) "||") 
		) (then 
			(set node (call node_expand node))
	))
	
	(if (= (get node type) @NODE_EXPR) (then
		(<< s "\n")
		(<< s indent)

		(let block_start str (alloc str "("))
		(<< block_start (get node value))
		(let block_end str (alloc str ")"))
		(let block_seperator str " ")

		(if (= (get node value) "func") (then
			(set block_start "function ")
			(let fname_node (struct node) (get (get node child) 0))
			(<< block_start (get fname_node value))
			(<< block_start	"(")

			(let param_count int 0)
			(let i int 0)
			(while (< i (# (get node child))) (do
				(let child_node (struct node) (get (get node child) i))
				(if (= (get child_node value) "param") (then
					(let param_node (struct node) (get (get child_node child) 0))
					(if (> param_count 0) (then
						(<< block_start ", ")
					))
					(<< block_start (get param_node value))
					(set param_count (+ param_count 1))
					(remove (get node child) i 1)	
					(set i (- i 1))
				))
				(if (= (get child_node value) "result") (then
					(remove (get node child) i 1)	
					(set i (- i 1))
				))
				(set i (+ i 1))
			))
			
			(<< block_start ") {")
			(set block_end "}")
			(remove (get node child) 0 1)
		))
		(if (= (get node value) "call") (then
			(let fname_node (struct node) (get (get node child) 0))
			(set block_start (get fname_node value))
			(<< block_start "(")
			(set block_end ")")
			(remove (get node child) 0 1)
			(set block_seperator ",")
		))
		(if (|| 
			(= (get node value) "let") 
			(= (get node value) "local"))
			(then
			(set block_start "let ")
			(set block_end "")
			(remove (get node child) 1 1)
			(if (= (# (get node child)) 2) (then
				(insert (get node child) 1 (call node_new @NODE_STR "="))
			))
		))
		(if (= (get node value) "alloc") (then
			(set block_start "")
			(set block_end "")
			
			(if (= @NODE_EXPR (get (get (get node child) 0) type)) (then
				(set block_start "[]")
			))
			(if (= @NODE_STR (get (get (get node child) 0) type)) (then
				(set block_start "\"\"")
			))

			(remove (get node child) 0 1)
		))
		(if (= (get node value) "free") (then
			(set block_start "/*GC*/")
			(set block_end "")

			(remove (get node child) 0 1)
		))
		(if (= (get node value) "vec") (then
			(set block_start "XXX")
			(set block_end "XXXX")
			(remove (get node child) 0 1)
		))
		(if (= (get node value) "#") (then
			(set block_start "")
			(set block_end ".length")
		))
		(if (= (get node value) "insert") (then
			(set block_start (call node_to_js (+ depth 1) (get (get node child) 0)))
			(<< block_start ".splice(")
			(<< block_start (call node_to_js (+ depth 1) (get (get node child) 1)))
			(<< block_start ",0,")
			(<< block_start (call node_to_js (+ depth 1) (get (get node child) 2)))
			(set block_end ")")
			(while (> (# (get node child)) 0) (do
				(remove (get node child) 0 1)
			))
		))
		(if (= (get node value) "remove") (then
			(set block_start (call node_to_js (+ depth 1) (get (get node child) 0)))
			(<< block_start ".splice(")
			(<< block_start (call node_to_js (+ depth 1) (get (get node child) 1)))
			(<< block_start ",")
			(<< block_start (call node_to_js (+ depth 1) (get (get node child) 2)))
			(set block_end ")")
			(while (> (# (get node child)) 0) (do
				(remove (get node child) 0 1)
			))
		))
		(if (= (get node value) "get") (then
			(set block_start (call node_to_js (+ depth 1) (get (get node child) 0)))
			(set block_end "")
			(for i 1 (< i (# (get node child))) 1 (do
				(<< block_end "[")
				(<< block_end (call node_to_js (+ depth 1) (get (get node child) i)))
				(<< block_end "]")
			))
			(while (> (# (get node child)) 0) (do
				(remove (get node child) 0 1)
			))
		))
		(if (= (get node value) "set") (then
			(set block_start (call node_to_js (+ depth 1) (get (get node child) 0)))
			(set block_end "")
			(let child_last_index int (- (# (get node child))1))
			(for i 1 (< i child_last_index) 1 (do
				(<< block_end "[")
				(<< block_end (call node_to_js (+ depth 1) (get (get node child) i)))
				(<< block_end "]")
			))
			(<< block_end "=")
			(<< block_end (call node_to_js (+ depth 1) (get (get node child) child_last_index)))

			(while (> (# (get node child)) 0) (do
				(remove (get node child) 0 1)
			))
		))
		(if (= (get node value) "cast") (then
			(set block_start "\"\"+")
			(set block_end (get (get (get node child) 0) value))
			(remove (get node child) 0 1)
			(remove (get node child) 0 1)
		))
		(if (= (get node value) "if") (then
			(set block_start "if")
			(set block_end "")
		))
		(if (= (get node value) "then") (then
			(set block_start "{")
			(set block_end "}")
		))
		(if (= (get node value) "else") (then
			(set block_start "else {")
			(set block_end "}")
		))
		(if (= (get node value) "for") (then
			(set block_start "for (")
			(<< block_start (get (get (get node child) 0) value))
			(<< block_start "=")
			(<< block_start (get (get (get node child) 1) value))
			(<< block_start ";")
			(<< block_start (call node_to_js (+ depth 1) (get (get node child) 2)))
			(<< block_start ";")
			(<< block_start (get (get (get node child) 0) value))
			(<< block_start "+=")
			(<< block_start (get (get (get node child) 3) value))
			(<< block_start ")")
			(remove (get node child) 0 4)

			(set block_end "")
		))
		(if (= (get node value) "while") (then
			(set block_start "while")
			(set block_end "")
		))
		(if (= (get node value) "do") (then
			(set block_start "{")
			(set block_end "}")
		))
		(if (= (get node value) "?") (then
			(set block_start (call node_to_js (+ depth 1) (get (get node child) 0)))
			(<< block_start " ? ")
			(<< block_start (call node_to_js (+ depth 1) (get (get node child) 1)))
			(<< block_start " : ")
			(<< block_start (call node_to_js (+ depth 1) (get (get node child) 2)))
			(set block_end "")
			(while (> (# (get node child)) 0) (do
				(remove (get node child) 0 1)
			))
		))
		(if (= (get node value) "print") (then
			(set block_start "console.log(")
		))
		(if (= (get node value) "<<") (then
			(set block_start "(")
			(insert (get node child) 1 (call node_new @NODE_STR "+="))
		))
		(if (= (get node value) "=") (then
			(set block_start "(")
			(set block_end ")")
			(insert (get node child) 1 (call node_new @NODE_STR "=="))
		))
		(if (|| 
			(= (get node value) "%%") 
			(= (get node value) "&&") 
			(= (get node value) "||") 
			(= (get node value) ">=") 
			(= (get node value) "<=") 
			(= (get node value) "<>") 
			(= (get node value) "+")
			(= (get node value) "-")
			(= (get node value) "*")
			(= (get node value) "/")
			(= (get node value) "^")
			(= (get node value) "%")
			(= (get node value) "&")
			(= (get node value) "|")
			(= (get node value) "~")
			(= (get node value) "<")
			(= (get node value) ">")
			)(then
			(set block_start "(")
			(set block_end ")")
			(insert (get node child) 1 (call node_new @NODE_STR (get node value)))
		))
		(if (= (get node value) "return") (then
			(set block_start "return(")
			(set block_end ")")
		))

		(<< s block_start)

		(let last_child_expr int 0)
		(for i 0 (< i (# (get node child))) 1 (do
			(let node_child (struct node) (get (get node child) i))
			(set last_child_expr (= (get node_child type) @NODE_EXPR))
			(let child str (call node_to_js (+ depth 1) node_child))
			(if (> i 0) (then
				(<< s block_seperator)
			))
			(<< s child)
			(if (||
				(= (get node value) "func")
				(= (get node value) "do")
				(= (get node value) "then")
				(= (get node value) "else")) (then
					(<< s ";")
				)
			)
		))
		
		(if last_child_expr (then
			(<< s "\n")
			(<< s indent)
		))
		(<< s block_end)
	))

	(if (= (get node type) @NODE_STR) (then
		(<< s (get node value))
	))
	
	(return s)
)

(func node_to_c (param depth int) (param node (struct node)) (result str)
	(return "node_to_c not implemented")
)

(func prog_helloworld_raw (result (struct node))
 	(let root (struct node) (call node_new @NODE_ROOT ""))
	
	(let hello_func (struct node) (call node_new @NODE_EXPR "func"))
 	(insert (get root child) (# (get root child)) hello_func)
	
	(let func_main (struct node) (call node_new @NODE_STR "main"))
 	(insert (get hello_func child) (# (get hello_func child)) func_main)
	
	(let func_result (struct node) (call node_new @NODE_EXPR "result"))
 	(insert (get hello_func child) (# (get hello_func child)) func_result)

	(let result_int (struct node) (call node_new @NODE_STR "int"))
 	(insert (get func_result child) (# (get func_result child)) result_int)
	
	(let func_print (struct node) (call node_new @NODE_EXPR "print"))
	(insert (get hello_func child) (# (get hello_func child)) func_print)
	
	(let print_hello (struct node) (call node_new @NODE_STR "Hello World!"))
 	(insert (get func_print child) (# (get func_print child)) print_hello)
	
	(let func_return (struct node) (call node_new @NODE_EXPR "return"))
	(insert (get hello_func child) (# (get hello_func child)) func_return)
	
	(let return_0 (struct node) (call node_new @NODE_STR "0"))
 	(insert (get func_return child) (# (get func_return child)) return_0)

	(return root)
)

(func main (result int)
 	; (let root (struct node) (call prog_helloworld_raw))

	; (let prog str (call prog_helloworld))
	; (let prog str (call prog_vecmap))
	; (let prog str (call prog_fib))
	; (let prog str (call prog_nqueens))
	(let prog str (call prog_hilbert))
	(let tokens (arr str) (call tokens_parse prog))

	; (let s str (alloc str ""))
	; (for i 0 (< i (# tokens)) 1 (do
	; 	(set s "'")
	; 	(<< s (get tokens i))
	; 	(<< s "'")
	; 	(print s)
	; ))

	(let root (struct node) (call node_from_tokens tokens))
	; (let root (struct node) (call prog_helloworld_raw))
   	
	; (let out str (call node_to_wax 0 root))
   	(let out str (call node_to_js 0 root))
	
	(print out)
	(return 0)
)
