; ---------------------------------------------------------------------------- 
; - Tokenizer -
; ---------------------------------------------------------------------------- 

(@define CHAR_TAB 9)
(@define CHAR_NL 10)
(@define CHAR_SPACE 32)
(@define CHAR_DOUBLE_QUOTE 34)
(@define CHAR_SINGLE_QUOTE 39)
(@define CHAR_PAREN_OPEN 40)
(@define CHAR_PAREN_CLOSE 41)
(@define CHAR_SEMICOLON 59)

(func tokens_parse (param input str) (result (arr str))
	(let token str (alloc str))
	(let tokens (arr str) (alloc (arr str)))
	(let in_comment int 0)
	(let in_single_quote int 0)
	(let in_double_quote int 0)
	(let in_quote int 0)

	(for i 0 (< i (# input)) 1 (do
		(let c int (get input i))

		(if (= c @CHAR_SEMICOLON) (then
			(set in_comment 1)
		))
		(if (= c @CHAR_NL) (then
			(if in_comment (then
				(set token "")
			))
			(set in_comment 0)
		))
		
		(if (&& (! in_double_quote) (= c @CHAR_SINGLE_QUOTE)) (then 
			(set in_single_quote (! in_single_quote))
		))
		(if (&& (! in_single_quote) (= c @CHAR_DOUBLE_QUOTE)) (then 
			(set in_double_quote (! in_double_quote))
		))
		(set in_quote (|| in_single_quote in_double_quote))

		(let whitespace int (|| (= c @CHAR_TAB) (= c @CHAR_SPACE) (= c @CHAR_NL)))
		(let paren int (|| (= c @CHAR_PAREN_OPEN) (= c @CHAR_PAREN_CLOSE)))

		(if (&& (! in_quote) (! in_comment) (|| whitespace paren)) (then
			(if (> (# token) 0) (then
				(insert tokens (# tokens) token)
			))

			(if paren (then
				(set token "")
				(<< token c)
 				(insert tokens (# tokens) token)
			))

			(set token "")
			) (else 
				(<< token c)
			)
		)
	))

	(return tokens)
)

(func tokens_to_string (param tokens (arr str)) (param width int) (result str)
	(let s str (alloc str ""))
	(let line str (alloc str ""))
	(for i 0 (< i (# tokens)) 1 (do
		(let token str "")
		(for j 0 (< j (# (get tokens i))) 1 (do
			(let c int (get (get tokens i) j))
			(let encoded str "")
			(<< encoded c)
			(if (= c '\"') (then
				(set encoded "\\\"")
			))
			(if (= c '\\') (then
				(set encoded "")
				(<< encoded '\\')
				(<< encoded '\\')
			))
			(<< token encoded)
		))

		(<< line token)
		(if (> (# line) width) (then
			(<< s "\"")
			(<< s line)
			(<< s "\\n\"\n")
			(set line "")
		) (else
			(if (&& 
				(<> token "(") 
				(<> token ")")
				) (then
				(<< line " ")
			))
		))
	))
	(<< s "\"")
	(<< s line)
	(<< s "\\n\"\n")

	(return s)
)

; ---------------------------------------------------------------------------- 
; - S-Expression Node tree -
; ---------------------------------------------------------------------------- 

(@define NODE_ROOT 0)
(@define NODE_EXPR 1)
(@define NODE_PREPROCESS 2)
(@define NODE_CHAR 3)
(@define NODE_STR 4)
(@define NODE_STR_QUOTE 5)
(@define NODE_INT 6)
(@define NODE_FLOAT 7)

(struct node
	(let type int)
	(let value str)
	(let child (arr (struct node)))
)

(func node_new (param type int) (param value str) (result (struct node))
	(let node_new (struct node) (alloc (struct node)))
	(set node_new type type)
	(set node_new value value)
	(set node_new child (alloc (arr (struct node))))
	
	(return node_new)
)

(func node_type_from_token (param token str) (result int)
	(if (> (# token) 0) (then
		(if (= (get token 0) '@') (then
			(return @NODE_PREPROCESS)
		))
		(if (= (get token 0) '\'') (then
			(return @NODE_CHAR)
		))
		(if (= (get token 0) '\"') (then
			(return @NODE_STR_QUOTE)
		))
		(if (&&
			(>= (get token 0) '0')
			(<= (get token 0) '9')
			) (then
				(return @NODE_INT)
		))
	))

	(return @NODE_STR)
)

(func node_from_tokens (param tokens (arr str)) (result (struct node))
	(let stack (arr (struct node)) (alloc (arr (struct node))))
	(insert stack (# stack) (call node_new @NODE_ROOT ""))

	(let i int 0)
	(while (< i (# tokens)) (do
		(let token str (get tokens i))

		(if (= token "(") (then
			(let node (struct node)
				(call node_new @NODE_EXPR (get tokens (+ i 1)))
			)
			(let parent (struct node) (get stack (- (# stack) 1)))
			(insert (get parent child) (# (get parent child)) node)
			(insert stack (# stack) node)
		
			(set i (+ i 1))			
			) 
			(else (if (= token ")") (then
				(remove stack (- (# stack) 1) 1)
			) 
				(else
					(let child (struct node)
						(call node_new (call node_type_from_token token) token)
					)
					(let node (struct node) (get stack (- (# stack) 1)))
					(insert (get node child) (# (get node child)) child)
				))
			)
		)

		(set i (+ i 1))
	))

	(return (get stack 0))
)

; eg (+ a b c) -> (+ (+ a b) c) 
(func node_expand (param node_org (struct node)) (result (struct node))
	(if (< (# (get node_org child)) 2) (then
		(return node_org)
	))
	
	(let expanded (struct node) (call node_new @NODE_EXPR (get node_org value)))

	(insert (get expanded child) (# (get expanded child)) (get (get node_org child) 0))
	(if (= (# (get node_org child)) 2) (then
		(insert (get expanded child) (# (get expanded child)) (get (get node_org child) 1))
	) (else
		(let expanded_child (struct node) (call node_new @NODE_EXPR (get node_org value)))
		(for i 1 (< i (# (get node_org child))) 1 (do
			(insert (get expanded_child child) (# (get expanded_child child)) (get (get node_org child) i))
		))

		(insert (get expanded child) (# (get expanded child)) expanded_child)
	))
	(return expanded)
)

(func node_indent_needed (param node (struct node)) (param child (struct node)) (result int)
	(if (<> (get child type) @NODE_EXPR) (then
		(return 0)
	))

	(if (||
		(= (get child value) "param") 
		(= (get child value) "result")
		) (then
			(return 0)
	))
	(if (||
		(= (get node value) "func")
		(= (get node value) "do")
		(= (get node value) "then")
		(= (get node value) "else")
		(= (get node value) "struct")
		(= (get node value) "&&")
		(= (get node value) "||")
		) (then
			(return 1)
		)
	)
)

; ----------------------------------------------------------------------------
; - WAX language target -
; ----------------------------------------------------------------------------

(func node_to_wax (param depth int) (param node (struct node)) (result str)
	(let s str (alloc str ""))
	(let indent str "  ")
	
	(if (= (get node type) @NODE_ROOT) (then
		(for i 0 (< i (# (get node child))) 1 (do
			(let child str (call node_to_wax 0 (get (get node child) i)))
			(<< s child)
			(<< s "\n")
		))
	))

	(if (= (get node type) @NODE_EXPR) (then
		(<< s "(")
		(<< s (get node value))
		(for i 0 (< i (# (get node child))) 1 (do
			(let node_child (struct node) (get (get node child) i))
			(let indent_needed int (call node_indent_needed node node_child))
			(let indent_depth int (? indent_needed depth (- depth 1)))
		
			(if indent_needed (then
				(<< s "\n")
				(for i 0 (<= i indent_depth) 1 (do
					(<< s indent)
				))
			) (else 
				(<< s " ")
			))

			(let child str (call node_to_wax (+ indent_depth 1) node_child))
			(<< s child)

			(if (&& 
				indent_needed
				(= i (- (# (get node child)) 1)) ; is last child
				) (then
				(<< s "\n")
				(for i 0 (< i indent_depth) 1 (do
					(<< s indent)
				))
			))

		))
		(<< s ")")
	))

	(if (<> (get node type) @NODE_EXPR) (then
		(<< s (get node value))
	))

	(return s)
)

; ----------------------------------------------------------------------------
; - JavaScript language target -
; ----------------------------------------------------------------------------

(func node_to_js (param depth int) (param node (struct node)) (result str)
	(let indent str (alloc str ""))
	(for i 0 (< i depth) 1 (do
		(<< indent "  ")
	))
	
	(let s str (alloc str ""))
	
	(if (= (get node type) @NODE_ROOT) (then
		(for i 0 (< i (# (get node child))) 1 (do
			(let child str (call node_to_js 0 (get (get node child) i)))
			(<< s child)
		))
		
		(<< s "\n\n")
		(<< s "main()\n")
	))

	(if (|| 
		(= (get node value) "+") 
		(= (get node value) "||") 
		) (then 
			(set node (call node_expand node))
	))
	
	(if (= (get node type) @NODE_EXPR) (then
		(<< s "\n")
		(<< s indent)

		(let block_start str (alloc str "("))
		(<< block_start (get node value))
		(let block_end str (alloc str ")"))
		(let block_seperator str " ")

		(if (= (get node value) "@define") (then
			(set block_start "const ")
			(<< block_start (get (get (get node child) 0) value))
			(<< block_start "=")
			(<< block_start (get (get (get node child) 1) value))
			(<< block_start ";")

			(set block_end "")
			(while (> (# (get node child)) 0) (do
				(remove (get node child) 0 1)
			))
		))
		(if (= (get node value) "struct") (then
			(set block_start "")
			(set block_end "")
			(while (> (# (get node child)) 0) (do
				(remove (get node child) 0 1)
			))
		))
		(if (= (get node value) "func") (then
			(set block_start "function ")
			(let fname_node (struct node) (get (get node child) 0))
			(<< block_start (get fname_node value))
			(<< block_start	"(")

			(let param_count int 0)
			(let i int 0)
			(while (< i (# (get node child))) (do
				(let child_node (struct node) (get (get node child) i))
				(if (= (get child_node value) "param") (then
					(let param_node (struct node) (get (get child_node child) 0))
					(if (> param_count 0) (then
						(<< block_start ", ")
					))
					(<< block_start (get param_node value))
					(set param_count (+ param_count 1))
					(remove (get node child) i 1)	
					(set i (- i 1))
				))
				(if (= (get child_node value) "result") (then
					(remove (get node child) i 1)	
					(set i (- i 1))
				))
				(set i (+ i 1))
			))
			
			(<< block_start ") {")
			(set block_end "}")
			(remove (get node child) 0 1)
		))
		(if (= (get node value) "call") (then
			(let fname_node (struct node) (get (get node child) 0))
			(set block_start (get fname_node value))
			(<< block_start "(")
			(set block_end ")")
			(remove (get node child) 0 1)
			(set block_seperator ",")
		))
		(if (|| 
			(= (get node value) "let") 
			(= (get node value) "local"))
			(then
			(set block_start "let ")
			(set block_end "")
			(remove (get node child) 1 1)
			(if (= (# (get node child)) 2) (then
				(insert (get node child) 1 (call node_new @NODE_STR "="))
			))
		))
		(if (= (get node value) "alloc") (then
			(set block_start "")
			(set block_end "")
			
			(if (>= (# (get node child)) 2) (then
				(set block_start (call node_to_js (+ depth 1) (get (get node child) 1)))
			) (else
				(let child (struct node) (get (get node child) 0))
				(if (= (get child type) @NODE_EXPR) (then
					(if (|| 
						(= (get (get (get node child) 0) value) "arr")
						(= (get (get (get node child) 0) value) "vec"))
						(then
							(set block_start "[]")
						)
					)
					(if (||
						(= (get (get (get node child) 0) value) "map")
						(= (get (get (get node child) 0) value) "struct"))
						(then
							(set block_start "{}")
						)
					)
				))
				(if (= (get child type) @NODE_STR) (then
					(set block_start "\"\"")
				))
			))
			(while (> (# (get node child)) 0) (do
				(remove (get node child) 0 1)
			))
		))
		(if (= (get node value) "free") (then
			(set block_start "/*GC*/")
			(set block_end "")

			(remove (get node child) 0 1)
		))
		(if (= (get node value) "vec") (then
			(set block_start "XXX")
			(set block_end "XXXX")
			(remove (get node child) 0 1)
		))
		(if (= (get node value) "#") (then
			(set block_start "")
			(set block_end ".length")
		))
		(if (= (get node value) "insert") (then
			(set block_start (call node_to_js (+ depth 1) (get (get node child) 0)))
			(<< block_start ".splice(")
			(<< block_start (call node_to_js (+ depth 1) (get (get node child) 1)))
			(<< block_start ",0,")
			(<< block_start (call node_to_js (+ depth 1) (get (get node child) 2)))
			(set block_end ")")
			(while (> (# (get node child)) 0) (do
				(remove (get node child) 0 1)
			))
		))
		(if (= (get node value) "remove") (then
			(if (= (get (get (get node child) 1) type) @NODE_INT) (then
				(set block_start (call node_to_js (+ depth 1) (get (get node child) 0)))
				(<< block_start ".splice(")
				(<< block_start (call node_to_js (+ depth 1) (get (get node child) 1)))
				(<< block_start ",")
				(<< block_start (call node_to_js (+ depth 1) (get (get node child) 2)))
				(set block_end ")")
			))
			(if (= (get (get (get node child) 1) type) @NODE_STR_QUOTE) (then
				(set block_start "delete ")
				(<< block_start (call node_to_js (+ depth 1) (get (get node child) 0)))
				(<< block_start "[")
				(<< block_start (call node_to_js (+ depth 1) (get (get node child) 1)))
				(set block_end "]")
			))
			(while (> (# (get node child)) 0) (do
				(remove (get node child) 0 1)
			))
		))
		(if (= (get node value) "get") (then
			(set block_start (call node_to_js (+ depth 1) (get (get node child) 0)))
			(set block_end "")
			(for i 1 (< i (# (get node child))) 1 (do
				(let child (struct node) (get (get node child) i))
				(if (&& (= (get child type) @NODE_STR) (> (# (get child value)) 1))
					(then
						(<< block_end ".")
						(<< block_end (call node_to_js (+ depth 1) (get (get node child) i)))
						(<< block_end "")
					) (else
						(<< block_end "[")
						(<< block_end (call node_to_js (+ depth 1) (get (get node child) i)))
						(<< block_end "]")
					)
				)
			))
			(while (> (# (get node child)) 0) (do
				(remove (get node child) 0 1)
			))
		))
		(if (= (get node value) "set") (then
			(set block_start (call node_to_js (+ depth 1) (get (get node child) 0)))
			(set block_end "")
			(let child_last_index int (- (# (get node child)) 1))
			(for i 1 (< i child_last_index) 1 (do
				(let child (struct node) (get (get node child) i))
				(if (&& (= (get child type) @NODE_STR) (> (# (get child value)) 1))
					(then
						(<< block_end ".")
						(<< block_end (call node_to_js (+ depth 1) (get (get node child) i)))
						(<< block_end "")
					) (else 
						(<< block_end "[")
						(<< block_end (call node_to_js (+ depth 1) (get (get node child) i)))
						(<< block_end "]")
					)
				)
			))
			(<< block_end "=")
			(<< block_end (call node_to_js (+ depth 1) (get (get node child) child_last_index)))

			(while (> (# (get node child)) 0) (do
				(remove (get node child) 0 1)
			))
		))
		(if (= (get node value) "cast") (then
			(set block_start "\"\"+")
			(set block_end (call node_to_js (+ depth 1) (get (get node child) 0)))
			(remove (get node child) 0 1)
			(remove (get node child) 0 1)
		))
		(if (= (get node value) "if") (then
			(set block_start "if")
			(set block_end "")
		))
		(if (= (get node value) "then") (then
			(set block_start "{")
			(set block_end "}")
		))
		(if (= (get node value) "else") (then
			(set block_start "else {")
			(set block_end "}")
		))
		(if (= (get node value) "for") (then
			(if (= (# (get node child)) 5) (then 
				(set block_start "for (")
				(<< block_start (call node_to_js (+ depth 1) (get (get node child) 0)))
				(<< block_start "=")
				(<< block_start (call node_to_js (+ depth 1) (get (get node child) 1)))
				(<< block_start ";")
				(<< block_start (call node_to_js (+ depth 1) (get (get node child) 2)))
				(<< block_start ";")
				(<< block_start (call node_to_js (+ depth 1) (get (get node child) 0)))
				(<< block_start "+=")
				(<< block_start (call node_to_js (+ depth 1) (get (get node child) 3)))
				(<< block_start ")")
				(remove (get node child) 0 4)
				(set block_end "")
			))
			(if (= (# (get node child)) 4) (then 
				(set block_start "for (const [")
				(<< block_start (call node_to_js (+ depth 1) (get (get node child) 0)))
				(<< block_start ",")
				(<< block_start (call node_to_js (+ depth 1) (get (get node child) 1)))
				(<< block_start "] of Object.entries(")
				(<< block_start (call node_to_js (+ depth 1) (get (get node child) 2)))
				(<< block_start "))")
				(remove (get node child) 0 3)
				(set block_end "")
			))
		))
		(if (= (get node value) "while") (then
			(set block_start "while(")
			(<< block_start (call node_to_js (+ depth 1) (get (get node child) 0)))
			(<< block_start ")")
			(set block_end "")
			(remove (get node child) 0 1)
		))
		(if (= (get node value) "do") (then
			(set block_start "{")
			(set block_end "}")
		))
		(if (= (get node value) "break") (then
			(set block_start "break")
			(set block_end "")
		))
		(if (= (get node value) "?") (then
			(set block_start (call node_to_js (+ depth 1) (get (get node child) 0)))
			(<< block_start " ? ")
			(<< block_start (call node_to_js (+ depth 1) (get (get node child) 1)))
			(<< block_start " : ")
			(<< block_start (call node_to_js (+ depth 1) (get (get node child) 2)))
			(set block_end "")
			(while (> (# (get node child)) 0) (do
				(remove (get node child) 0 1)
			))
		))
		(if (= (get node value) "print") (then
			(set block_start "console.log(")
		))
		(if (|| 
			(= (get node value) ">>")
			(= (get node value) "<<")
			(= (get node value) "=")
			(= (get node value) "&&")
			(= (get node value) "||") 
			(= (get node value) ">=") 
			(= (get node value) "<=") 
			(= (get node value) "<>") 
			(= (get node value) "+")
			(= (get node value) "-")
			(= (get node value) "*")
			(= (get node value) "/")
			(= (get node value) "^")
			(= (get node value) "%")
			(= (get node value) "&")
			(= (get node value) "|")
			(= (get node value) "~")
			(= (get node value) "<")
			(= (get node value) ">")
			)(then
				(set block_start "(")
				(set block_end ")")
				
				(if (&& 
					(= (get node value) "<<") 
					(= (get (get (get node child) 0) type) @NODE_STR) 
					) (then
					(set node value "+=")
				))
				(if (= (get node value) "=") (then
					(set node value "==")
				))
				(insert (get node child) 1 (call node_new @NODE_STR (get node value)))
		))
		(if (= (get node value) "return") (then
			(set block_start "return(")
			(set block_end ")")
		))

		(<< s block_start)

		(let last_child_expr int 0)
		(for i 0 (< i (# (get node child))) 1 (do
			(let node_child (struct node) (get (get node child) i))
			(set last_child_expr (= (get node_child type) @NODE_EXPR))
			(let child str (call node_to_js (+ depth 1) node_child))
			(if (> i 0) (then
				(<< s block_seperator)
			))
			(<< s child)
			(if (||
				(= (get node value) "func")
				(= (get node value) "do")
				(= (get node value) "then")
				(= (get node value) "else")) (then
					(<< s ";")
				)
			)
		))
		
		(if last_child_expr (then
			(<< s "\n")
			(<< s indent)
		))
		(<< s block_end)
	))

	(if (<> (get node type) @NODE_EXPR) (then
		(let value str (get node value))
		(if (= (get node type) @NODE_PREPROCESS) (then
			(<< s (slice value 1 (- (# value) 1)))	
		) (else 
			(<< s value)
		))
	))
	
	(return s)
)

; ----------------------------------------------------------------------------
; - C language target -
; ----------------------------------------------------------------------------

(func node_to_c (param depth int) (param node (struct node)) (result str)
	(return "node_to_c not implemented")
)

; ----------------------------------------------------------------------------
; - Example Programs and main function -
; ----------------------------------------------------------------------------

(func prog_helloworld (result str)
	(let lines (arr str) (alloc (arr str)
		"(func main (result int)"
		"  (print \"Hello World!\")"
		"  (return 0)"
		")"
	))

	(let prog str (alloc str ""))
	(for i 0 (< i (# lines)) 1 (do
		(<< prog (get lines i))
	))

	(return prog)
)

(func prog_fib (result str)
	(let lines (arr str) (alloc (arr str)
		";; Simple recursive function to compute\n"
		";; Fibonacci numbers\n"
		"(func fib (param i int) (result int)"
		"	(if (<= i 1) (then\n"
		"		(return i)"
		"	))"
		"	(return (+\n"
		"		(call fib (- i 1))\n"
		"		(call fib (- i 2))\n"
		"	))\n"
		")"
		"\n"
		"(func main (result int)\n"
		"	(let x int (call fib 9))\n"
		"	(print x)\n"
		"	(return 0)\n"
		")\n"
	))

	(let prog str (alloc str ""))
	(for i 0 (< i (# lines)) 1 (do
		(<< prog (get lines i))
	))

	(return prog)
)

(func prog_strings (result str)
	(let lines (arr str) (alloc (arr str)
		"(func main (result int)"
		"  (let str_noalloc str)"
		"  (let str_alloc str (alloc str))"
		"  (let str_alloc_init str (alloc str \"init\"))"
		"  (let buf (alloc str) \"init\")"
		"  (<< buf ':')"
		"  (<< buf \"append\")"
		"  (print buf)"
		"  (let double_quote str \"quote double contains 'quote single' string\")"
		"  (print double_quote)"
		"  (let double_quote_apostrophe str \"quote double contains apostrophe's string\")"
		"  (print double_quote_apostrophe)"
		"  (let single_quote str 'quote single contains \"quote double\" string')"
		"  (print single_quote)"
		"  (let non_string_op int (<< 1 8))"
		"  (print non_string_op)"
		"  (return 0)"
		")"
	))

	(let prog str (alloc str ""))
	(for i 0 (< i (# lines)) 1 (do
		(<< prog (get lines i))
	))

	(return prog)
)

(func prog_arrvec (result str)
	(let lines (arr str) (alloc (arr str)
		"(func main (result int)"
		"  (let things (arr float) (alloc (arr float)))"
		"  (insert things 0 4.0)"
		"  (insert things 0 3.0)"
		"  (insert things 0 3.1)"
 		"  (insert things 0 3.2)"
		"  (insert things 0 1.0)"
		"  (insert things 1 2.0)"
		"  (remove things 2 2)"
		"  (for i 0 (< i (# things)) 1 (do"
		"    (print (get things i))"
		"  ))"
		"  (return 0)"
		")"
	))

	(let prog str (alloc str ""))
	(for i 0 (< i (# lines)) 1 (do
		(<< prog (get lines i))
	))

	(return prog)
)

(func prog_structmap (result str)
	(let lines (arr str) (alloc (arr str)
		"(func main (result int)"
		"  (struct point((let posx int)(let posy int))"
		"  (let s (struct point) (alloc (struct point)))"
		"  (set s posx 20)"
		; "  (set s x 20)" - will fail
		"  (print (get s posx))"
		"  (let m (map str int) (alloc (map str int))) "
		"  (set m \"xyz\" 999)"
		"  (print (get m \"xyz\"))"
		"  (remove m \"xyz\")"
		"  (print (get m \"xyz\"))"
		"  (set m \"abc\" 123)"
		"  (set m \"def\" 345)"
		"  (for k v m (do"
		"    (print k)"
		"    (print v)"
	    "  ))"
		"  (return 0)"
		")"
	))

	(let prog str (alloc str ""))
	(for i 0 (< i (# lines)) 1 (do
		(<< prog (get lines i))
	))

	(return prog)
)

(func prog_nqueens (result str)
	(let lines (arr str) (alloc (arr str)
		"(@define N 8 )(func attackable (param B (vec @N int ))(param y int )(result int )(let x int (get B y )\n"
		")(for i 1 (<= i y )1 (do (let t int (get B (- y i )))(if (|| (= t x )(= t (- x i ))(= t (+ x i )))(then\n"
		"(return 1 )))))(return 0 ))(func putboard (param B (vec @N int ))(param s int )(local o str (alloc str\n"
		"\"N=\" ))(<< o (cast @N str ))(<< o \" solution #\" )(<< o (cast s str ))(<< o \"\\n\" )(for y 0 (< y\n"
		"@N )1 (do (for x 0 (< x @N )1 (do (<< o (? (= (get B y )x )\"|Q\" \"|_\" ))))(<< o \"|\\n\" )))(print\n"
		"o ))(func solve (local B (vec @N int )(alloc (vec @N int )))(let s int 0 )(let y int 0 )(set B 0 -1 )\n"
		"(while (>= y 0 )(do (set B y (+ (get B y )1 ))(while (&& (< (get B y )@N )(call attackable B y ))(do (\n"
		"set B y (+ (get B y )1 ))))(if (< (get B y )@N )(then (if (< y (- @N 1 ))(then (set y (+ y 1 ))(set B\n"
		"y -1 ))(else (set s (+ s 1 ))(call putboard B s ))))(else (set y (- y 1 )))))))(func main (result int\n"
		")(call solve )(return 0 ))\n"
	))

	(let prog str (alloc str ""))
	(for i 0 (< i (# lines)) 1 (do
		(<< prog (get lines i))
	))

	(return prog)
)

(func prog_hilbert (result str)
	(let lines (arr str) (alloc (arr str)
		"(func rot (param n int )(param xy (vec 2 int ))(param rx int )(param ry int )(if (= ry 0 )(then (if (\n"
		"= rx 1 )(then (set xy 0 (- (- n 1 )(get xy 0 )))(set xy 1 (- (- n 1 )(get xy 1 )))))(let t int (get xy\n"
		"0 ))(set xy 0 (get xy 1 ))(set xy 1 t ))))(func d2xy (param n int )(param d int )(param xy (vec 2 int\n"
		"))(let rx int )(let ry int )(let t int d )(set xy 0 0 )(set xy 1 0 )(for s 1 (< s n )s (do (set rx (&\n"
		"1 (/ t 2 )))(set ry (& 1 (^ t rx )))(call rot s xy rx ry )(set xy 0 (+ (get xy 0 )(* s rx )))(set xy 1\n"
		"(+ (get xy 1 )(* s ry )))(set t (/ t 4 )))))(func hilbert_curve (param n int )(result (arr (vec 2 int\n"
		")))(let pts (arr (vec 2 int ))(alloc (arr (vec 2 int ))))(for d 0 (< d (* n n ))1 (do (let xy (vec 2 int\n"
		")(alloc (vec 2 int )))(call d2xy n d xy )(insert pts (# pts )xy )))(return pts ))(func draw_curve (param\n"
		"pts (arr (vec 2 int )))(param n int )(result str )(local canv (arr int )(alloc (arr int )))(let m int\n"
		"(- (* n 3 )2 ))(for i 0 (< i (* n m ))1 (do (insert canv (# canv )' ' )))(for i 1 (< i (# pts ))1 (do\n"
		"(let p0 (vec 2 int )(get pts (- i 1 )))(let p1 (vec 2 int )(get pts i ))(let dx int (- (get p1 0 )(get\n"
		"p0 0 )))(if (= dx 0 )(then (let row int (? (> (get p1 1 )(get p0 1 ))(get p1 1 )(get p0 1 )))(let col\n"
		"int (* (get p1 0 )3 ))(set canv (+ (* row m )col )'|' ))(else (let row int (get p1 1 ))(let col int (\n"
		"? (< (get p1 0 )(get p0 0 ))(get p1 0 )(get p0 0 )))(set col (+ (* col 3 )1 ))(set canv (+ (* row m )\n"
		"col )'_' )(set canv (+ (* row m )col 1 )'_' )))))(let s str (alloc str ))(for i 0 (< i n )1 (do (for j\n"
		"0 (< j m )1 (do (<< s (get canv (+ (* i m )j )))))(<< s '\\n' )))(return s ))(func main (result int )\n"
		"(for order 1 (<= order 5 )1 (do (let n int (<< 1 order ))(local pts (arr (vec 2 int ))(call hilbert_curve\n"
		"n ))(local s str (call draw_curve pts n ))(print s )(for i 0 (< i (# pts ))1 (do (free (get pts i )))\n"
		")))(return 0 ))\n"		
	))

	(let prog str (alloc str ""))
	(for i 0 (< i (# lines)) 1 (do
		(<< prog (get lines i))
	))

	(return prog)
)

(func prog_turing (result str)
	(let lines (arr str) (alloc (arr str)
		"(@define STAY 0 )(@define LEFT 1 )(@define RIGHT 2 )(struct transition (let q_curr int )(let q_targ int\n"
		")(let sym_r int )(let sym_w int )(let shift int ))(struct machine (let state int )(let head int )(let\n"
		"tape (map int int ))(let tmin int )(let tmax int ))(func step (param M (struct machine ))(param D (arr\n"
		"(struct transition )))(let tape (map int int )(get M tape ))(for i 0 (< i (# D ))1 (do (if (&& (= (get\n"
		"M state )(get D i q_curr ))(= (| (get tape (get M head ))0 )(get D i sym_r )))(then (set tape (get M head\n"
		")(get D i sym_w ))(set M state (get D i q_targ ))(if (= (get D i shift )@LEFT )(then (set M head (- (\n"
		"get M head )1 )))(else (if (= (get D i shift )@RIGHT )(then (set M head (+ (get M head )1 ))))))(break\n"
		")))))(if (< (get M head )(get M tmin ))(then (set M tmin (get M head ))))(if (> (get M head )(get M tmax\n"
		"))(then (set M tmax (get M head )))))(func draw (param M (struct machine ))(let s str (alloc str \"\"\n"
		"))(for i (get M tmin )(<= i (get M tmax ))1 (do (<< s (? (= i (get M head ))(get M state )' ' ))(<< s\n"
		"(? (get M tape i )'1' '_' ))(<< s \"  \" )))(print s ))(func turing (param D (arr (struct transition )\n"
		"))(param q0 int )(param q1 int )(local M (struct machine )(alloc (struct machine )))(local tape (map int\n"
		"int )(alloc (map int int )))(set M state q0 )(set M head 0 )(set M tape tape )(set M tmin 0 )(set M tmax\n"
		"0 )(call draw M )(while 1 (do (call step M D )(call draw M )(if (= (get M state )q1 )(then (break )))\n"
		")))(func defn (param D (arr (struct transition )))(param q_curr int )(param q_targ int )(param sym_r int\n"
		")(param sym_w int )(param shift int )(let d (struct transition )(alloc (struct transition )))(set d q_curr\n"
		"q_curr )(set d q_targ q_targ )(set d sym_r sym_r )(set d sym_w sym_w )(set d shift shift )(insert D (\n"
		"# D )d ))(func beaver3 (local D (arr (struct transition ))(alloc (arr (struct transition ))))(call defn\n"
		"D 'A' 'B' 0 1 @RIGHT )(call defn D 'A' 'C' 1 1 @LEFT )(call defn D 'B' 'A' 0 1 @LEFT )(call defn D 'B'\n"
		"'B' 1 1 @RIGHT )(call defn D 'C' 'B' 0 1 @LEFT )(call defn D 'C' 'H' 1 1 @STAY )(call turing D 'A' 'H'\n"
		")(for i 0 (< i (# D ))1 (do (free (get D i )))))(func beaver4 (local D (arr (struct transition ))(alloc\n"
		"(arr (struct transition ))))(call defn D 'A' 'B' 0 1 @RIGHT )(call defn D 'A' 'B' 1 1 @LEFT )(call defn\n"
		"D 'B' 'A' 0 1 @LEFT )(call defn D 'B' 'C' 1 0 @LEFT )(call defn D 'C' 'H' 0 1 @RIGHT )(call defn D 'C'\n"
		"'D' 1 1 @LEFT )(call defn D 'D' 'D' 0 1 @RIGHT )(call defn D 'D' 'A' 1 0 @RIGHT )(call turing D 'A' 'H'\n"
		")(for i 0 (< i (# D ))1 (do (free (get D i )))))(func main (result int )(call beaver4 )(return 0 ))\n"		
	))

	(let prog str (alloc str ""))
	(for i 0 (< i (# lines)) 1 (do
		(<< prog (get lines i))
	))

	(return prog)
)

(extern prog_readfile (param filename str) (result str))
(asm "declare var require: any;")
(asm "function prog_readfile(filename) {")
(asm "  let fs=require('fs');")
(asm "  return fs.readFileSync(filename).toString();")
(asm "}")

(func main (result int)
	; (let prog str (call prog_helloworld))
	; (let prog str (call prog_strings))
	; (let prog str (call prog_arrvec))
	; (let prog str (call prog_structmap))
	; (let prog str (call prog_fib))
	; (let prog str (call prog_nqueens))
	; (let prog str (call prog_hilbert))
	(let prog str (call prog_turing))
    ; (let prog str (call prog_readfile "/workspaces/wax/examples/compiler.wax"))

	(let tokens (arr str) (call tokens_parse prog))
	; (print (call tokens_to_string tokens 100))

	(let root (struct node) (call node_from_tokens tokens))
   	
	(let out str (call node_to_wax 0 root))
   	; (let out str (call node_to_js 0 root))
	(print out)

	(return 0)
)
