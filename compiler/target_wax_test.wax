(@include "test.wax")
(@include "node.wax")
(@include "target_wax.wax")

(func note_to_wax_test_empty
    ; Given - root node only
    (let test (struct test_test) (call test_init "note_to_wax_test_empty"))
    (let node_root (struct node) (call node_new @NODE_ROOT ""))

    ; When
    (let wax str (call node_to_wax 0 node_root))
    
    ; Then
    (call test_assert_equal test "" wax "wax source code")
)

(func note_to_wax_test_simple
    ; Given - single child node
    (let test (struct test_test) (call test_init "note_to_wax_test_empty"))
    (let node_root (struct node) (call node_new @NODE_ROOT ""))
    (let node_func (struct node) (call node_new @NODE_EXPR "func"))
    (insert (get node_root child) (# (get node_root child)) node_func)
    (let node_func_main (struct node) (call node_new @NODE_STR "main"))
    (insert (get node_func child) (# (get node_func child)) node_func_main)

    ; When
    (let wax str (call node_to_wax 0 node_root))
    
    ; Then
    (call test_assert_equal test "(func main)\n" wax "wax source code")
)

(func prog_helloworld (result str)
	(let lines (arr str) (alloc (arr str)
		"(func main (result int)"
		"  (print \"Hello World!\")"
		"  (return 0)"
		")"
	))

	(let prog str (alloc str ""))
	(for i 0 (< i (# lines)) 1 (do
		(<< prog (get lines i))
	))

	(return prog)
)

(func prog_fib (result str)
	(let lines (arr str) (alloc (arr str)
		";; Simple recursive function to compute\n"
		";; Fibonacci numbers\n"
		"(func fib (param i int) (result int)"
		"	(if (<= i 1) (then\n"
		"		(return i)"
		"	))"
		"	(return (+\n"
		"		(call fib (- i 1))\n"
		"		(call fib (- i 2))\n"
		"	))\n"
		")"
		"\n"
		"(func main (result int)\n"
		"	(let x int (call fib 9))\n"
		"	(print x)\n"
		"	(return 0)\n"
		")\n"
	))

	(let prog str (alloc str ""))
	(for i 0 (< i (# lines)) 1 (do
		(<< prog (get lines i))
	))

	(return prog)
)

(func prog_nqueens (result str)
	(let lines (arr str) (alloc (arr str)
		"(@define N 8 )(func attackable (param B (vec @N int ))(param y int )(result int )(let x int (get B y )\n"
		")(for i 1 (<= i y )1 (do (let t int (get B (- y i )))(if (|| (= t x )(= t (- x i ))(= t (+ x i )))(then\n"
		"(return 1 )))))(return 0 ))(func putboard (param B (vec @N int ))(param s int )(local o str (alloc str\n"
		"\"N=\" ))(<< o (cast @N str ))(<< o \" solution #\" )(<< o (cast s str ))(<< o \"\\n\" )(for y 0 (< y\n"
		"@N )1 (do (for x 0 (< x @N )1 (do (<< o (? (= (get B y )x )\"|Q\" \"|_\" ))))(<< o \"|\\n\" )))(print\n"
		"o ))(func solve (local B (vec @N int )(alloc (vec @N int )))(let s int 0 )(let y int 0 )(set B 0 -1 )\n"
		"(while (>= y 0 )(do (set B y (+ (get B y )1 ))(while (&& (< (get B y )@N )(call attackable B y ))(do (\n"
		"set B y (+ (get B y )1 ))))(if (< (get B y )@N )(then (if (< y (- @N 1 ))(then (set y (+ y 1 ))(set B\n"
		"y -1 ))(else (set s (+ s 1 ))(call putboard B s ))))(else (set y (- y 1 )))))))(func main (result int\n"
		")(call solve )(return 0 ))\n"
	))

	(let prog str (alloc str ""))
	(for i 0 (< i (# lines)) 1 (do
		(<< prog (get lines i))
	))

	(return prog)
)

(func main (result int)
  (call note_to_wax_test_empty)
  (call note_to_wax_test_simple)

  (return 0)
)